// Démonstration de la vulnérabilité SHA256 sans salt
const crypto = require('crypto')

// Votre fonction actuelle
function hashPassword(password) {
  return crypto.createHash('sha256').update(password).digest('hex')
}

// Simulation d'une base de données avec des mots de passe hashés
const userDatabase = [
  { username: 'alice', passwordHash: hashPassword('password123') },
  { username: 'bob', passwordHash: hashPassword('admin') },
  { username: 'charlie', passwordHash: hashPassword('password123') }, // Même mot de passe qu'Alice
  { username: 'david', passwordHash: hashPassword('123456') },
  { username: 'eve', passwordHash: hashPassword('password123') }, // Encore le même
]

console.log('🔍 Base de données simulée :')
userDatabase.forEach(user => {
  console.log(`${user.username}: ${user.passwordHash}`)
})

console.log('\n🚨 Attaque par dictionnaire :')
const commonPasswords = ['password123', 'admin', '123456', 'password', 'qwerty']

commonPasswords.forEach(password => {
  const hash = hashPassword(password)
  const victims = userDatabase.filter(user => user.passwordHash === hash)
  
  if (victims.length > 0) {
    console.log(`❌ Mot de passe "${password}" trouvé !`)
    console.log(`   Hash: ${hash}`)
    console.log(`   Victimes: ${victims.map(v => v.username).join(', ')}`)
    console.log('')
  }
})

console.log('💡 Avec bcrypt + salt, chaque hash serait unique même pour le même mot de passe !')
