// DÃ©monstration de la vulnÃ©rabilitÃ© SHA256 sans salt
const crypto = require('crypto')

// Votre fonction actuelle
function hashPassword(password) {
  return crypto.createHash('sha256').update(password).digest('hex')
}

// Simulation d'une base de donnÃ©es avec des mots de passe hashÃ©s
const userDatabase = [
  { username: 'alice', passwordHash: hashPassword('password123') },
  { username: 'bob', passwordHash: hashPassword('admin') },
  { username: 'charlie', passwordHash: hashPassword('password123') }, // MÃªme mot de passe qu'Alice
  { username: 'david', passwordHash: hashPassword('123456') },
  { username: 'eve', passwordHash: hashPassword('password123') }, // Encore le mÃªme
]

console.log('ğŸ” Base de donnÃ©es simulÃ©e :')
userDatabase.forEach(user => {
  console.log(`${user.username}: ${user.passwordHash}`)
})

console.log('\nğŸš¨ Attaque par dictionnaire :')
const commonPasswords = ['password123', 'admin', '123456', 'password', 'qwerty']

commonPasswords.forEach(password => {
  const hash = hashPassword(password)
  const victims = userDatabase.filter(user => user.passwordHash === hash)
  
  if (victims.length > 0) {
    console.log(`âŒ Mot de passe "${password}" trouvÃ© !`)
    console.log(`   Hash: ${hash}`)
    console.log(`   Victimes: ${victims.map(v => v.username).join(', ')}`)
    console.log('')
  }
})

console.log('ğŸ’¡ Avec bcrypt + salt, chaque hash serait unique mÃªme pour le mÃªme mot de passe !')
